package utils



import scala.collection.immutable.Range



case class RestrictedGrowthSequence(seq: Seq[Int]) {
  def concat(that: RestrictedGrowthSequence) = RestrictedGrowthSequence(this.seq ++ that.seq)
  def ++(that: RestrictedGrowthSequence) = concat(that)
}

/**
 * This class implements a Stirling Table of second kind
 * (see https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind)
 * The table is computed in a for loop and stored internally, to access an element
 *
 *
 * @param numElems number of elements the set (e.g. the variable n in wikipedia
 */
case class StirlingTable(numElems: Int) {

  type GrowthSequence = Seq[Int]

  private lazy val table = Array.fill(numElems + 1, numElems + 1)(BigInt(0))
  if (numElems <= 0) {
    table
  } else {
    for (j <- Range(1, numElems + 1))
      table(0)(j) = 0
    for (i <- Range(1, numElems + 1)) {
      table(i)(0) = 1
      for (j <- Range(1, numElems + 1)) {
        table(i)(j) = (j + 1) * table(i - 1)(j) + table(i - 1)(j - 1)
      }
    }
  }

  /** Simple function to print the table
   * TODO: Beautify the table printing
   */
  def printTable = {
    table.foreach{
      row => row.foreach{
        elem => print(elem.toString() + " ")
      }
      println("")
    }
  }

  /**
   * Gets the number of set partitions
   * @param n the size of the set of unique elements
   * @param k the number of similar partitions
   * @return number of partitions of set n into k partitions
   */
  def apply(n: Int, k: Int) = {
    assert(n <= numElems, s"Stirling number not computed for a set with ${n} (> ${numElems}) elements")
    table(n)(k - 1)
  }

  def get(n: Int, k: Int) = apply(n, k)

  /**
   * Implements a modified version of Ruskey's algorithm for finding
   * all of the restricted growth sequences of a set of [[numElems]] into
   * numParts partitions. the input ix defines the index of sequence in the space
   * as generated by Ruskey's algorithm. Note that Ruskey's algorithm can not be
   * practically and runs our of memory pretty quickly. Instead this function
   * prunes the growth sequence tree o only search relevant subtrees/subsequences that
   * will ultimately contain the growth sequence with index ix
   * See the __Art of Computer Programming Vol 4A, page 415__ for a treatment of the subject
   * and Ruskey's algorithm.
   * @param numParts number of partitions for a set with [[numElems]] elements
   * @param ix the index of restricted growth sequence in the set of all partitions
   * @return a Seq[Int] that represent a single restricted growth sequence
   */
  def growthSequence(numParts: Int, ix: BigInt): GrowthSequence = {

    def findSequence(n: Int, k: Int, i: BigInt)(primed: Boolean, reversed: Boolean): GrowthSequence = {
      if (n == k) {
        Seq.range(0, n)
      } else if (k == 1) {
        Seq.fill(n)(0.toInt)
      } else {
        assert(k > 0, "k > 0 failed")
        if (reversed) {
          val firstChild = get(n - 1, k)
          val lastChild = get(n - 1, k - 1)
          if (i >= firstChild * k) {
            // get the string from the last child
            val kIsOdd = k % 2 == 1
            findSequence(n - 1, k - 1, i - firstChild * k)(kIsOdd ^ primed, false) :+ (k - 1)
          } else {
            val quotient: BigInt = i / firstChild
            assert(quotient < k, "something went wrong!")
            // quotient < k also asserts that quotient can be safely converted to Int
            val remainder: BigInt = i % firstChild
            // get the string from one of k first children
            val nextSubSeq = quotient
            val isReversed: Boolean = (nextSubSeq.toInt % 2) == 1
            assert(nextSubSeq >= 0, "nextSubSeq >= 0 failed")
            findSequence(n - 1, k, remainder)(false, isReversed) :+ nextSubSeq.toInt
          }
        } else {
          val firstChild = get(n - 1, k - 1)
          val otherChildren = get(n - 1, k)

          if (i < firstChild) {
            // go in to the sub sequence corresponding to table(n - 1)(k - 1)
            val kIsOdd = k % 2 == 1
            findSequence(n - 1, k - 1, i)(kIsOdd ^ primed, false) :+ (k - 1)
          } else {
            val quotient: BigInt = (i - firstChild) / otherChildren
            val remainder: BigInt = (i - firstChild) % otherChildren
            val nextSubSeq: BigInt = (k - 1 - quotient)
            assert(nextSubSeq <= Int.MaxValue, "overflow detected!")
            assert(nextSubSeq >= 0, "nextSubSeq >= 0 failed with (i, k, q) = " + (i, k, quotient))
            val isReversed: Boolean = (nextSubSeq.toInt % 2) == 1
            findSequence(n - 1, k, remainder)(false, isReversed) :+ nextSubSeq.toInt
          }
        }
      }
    }
    require(ix < this(numElems, numParts), "index out of partition set range")
    findSequence(numElems, numParts, ix)(false, false)
  }
}

object Stirling {

  def recursive(numElems: Long, numParts: Long): Long = {
    require(numElems >= 0 && numParts >= 0, "Stirling function can be computed only with non-negative arguments")
    if (numElems < numParts) {
      0
    } else if (numElems == numParts) {
      1
    } else {
      if (numElems == 0 || numParts == 0)
        0
      else
        numParts * Stirling.recursive(numElems - 1, numParts) + Stirling.recursive(numElems - 1, numParts - 1)
    }
  }

//  def apply(numElems: Int, numParts: Int): Int = {
//    val numbers = Array.fill(numElems + 1, numParts)(0)
//    if (numElems <= 0 || numParts<= 0) {
//      numbers(0)(0)
//    } else {
//      for (j <- Range(1, numParts))
//        numbers(0)(j) = 0
//      for (i <- Range(1, numElems + 1)) {
//        numbers(i)(0) = 1
//        for (j <- Range(1, numParts)) {
//          numbers(i)(j) = (j + 1) * numbers(i - 1)(j) + numbers(i - 1)(j - 1)
//        }
//      }
//      numbers(numElems)(numParts - 1)
//    }
//  }
}

object RestrictedGrowthSequence {



  type RGSeq = Seq[Int]
  case class RGList(sequence: Seq[RGSeq]) {

    def :+(ext: Int) = RGList(sequence.map(_ :+ ext))
    def ++(that: RGList) = RGList(this.sequence ++ that.sequence)
    def reverse = RGList(this.sequence.reverse)
  }

  def apply(n: Int, m: Int): RGList = {
    RGS1(n, m)
  }


  private def RGS1(n: Int, m: Int): RGList = {

    if (m == 1) {
      RGList(Seq(Seq.fill(n)(0)))
    } else if (m == n) {
      RGList(Seq(Seq.range(0, n)))
    } else {
      val Amn1 = RGS1(n - 1, m)
      val isEven = m % 2 == 0
      def loop(j: Int): RGList =
        if (j == 0)
          Amn1 :+ 0
        else {
          val head = (if (j % 2 == 1) Amn1.reverse else Amn1) :+ j
          head ++ loop(j - 1)
        }
      if (isEven) {
        (RGS1(n - 1, m - 1) :+ (m - 1)) ++ loop(m - 1)
      } else {
        (RGS2(n - 1, m - 1) :+ (m - 1)) ++ loop(m - 1)
      }
    }
  }
  private def RGS2(n: Int, m: Int): RGList = {
    if (m == 1) {
      RGList(Seq(Seq.fill(n)(0)))
    } else if (m == n) {
      RGList(Seq(Seq.range(0, n)))
    } else {
      val Amn1 = RGS1(n - 1, m)
      val isEven = m % 2 == 0
      def loop(j: Int): RGList = {
        if (j == 0)
          Amn1.reverse :+ 0
        else {
          val head = (if (j % 2 == 0) Amn1 else Amn1.reverse) :+ j
          head ++ loop(j - 1)
        }
      }
      if (isEven) {
        (RGS2(n - 1, m - 1) :+ (m - 1)) ++ loop(m - 1)
      } else {
        (RGS1(n - 1, m - 1) :+ (m - 1)) ++ loop(m - 1)
      }
    }
  }

}